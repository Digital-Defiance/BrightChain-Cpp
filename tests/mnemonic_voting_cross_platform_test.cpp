#include <gtest/gtest.h>
#include <brightchain/member.hpp>
#include <brightchain/paillier.hpp>
#include <fstream>
#include <nlohmann/json.hpp>

using namespace brightchain;
using json = nlohmann::json;

static std::vector<uint8_t> hex_to_bytes(const std::string& hex) {
    std::vector<uint8_t> bytes;
    for (size_t i = 0; i < hex.length(); i += 2) {
        bytes.push_back(static_cast<uint8_t>(std::strtol(hex.substr(i, 2).c_str(), nullptr, 16)));
    }
    return bytes;
}

static std::string bytes_to_hex(const std::vector<uint8_t>& bytes) {
    std::ostringstream oss;
    for (uint8_t b : bytes) {
        oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(b);
    }
    return oss.str();
}

/**
 * CRITICAL TEST: Verify that TypeScript and C++ derive identical voting keys from the same mnemonic
 * 
 * Process:
 * 1. TypeScript generates member from mnemonic
 * 2. TypeScript derives voting keys using HKDF from ECDH
 * 3. TypeScript exports voting keys to JSON
 * 4. C++ loads same mnemonic
 * 5. C++ derives voting keys using same HKDF process
 * 6. Verify keys are IDENTICAL
 */
class MnemonicVotingKeyCrossPlatformTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Load test vectors generated by TypeScript
        std::ifstream f("tests/test_vectors_mnemonic_voting.json");
        if (!f.is_open()) f.open("test_vectors_mnemonic_voting.json");
        if (!f.is_open()) f.open("../tests/test_vectors_mnemonic_voting.json");
        if (!f.is_open()) f.open("../../tests/test_vectors_mnemonic_voting.json");
        
        if (f.is_open()) {
            vectors = json::parse(f);
            hasVectors = true;
        } else {
            hasVectors = false;
        }
    }
    
    json vectors;
    bool hasVectors;
};

TEST_F(MnemonicVotingKeyCrossPlatformTest, SameMnemonicProducesSameVotingKeys) {
    if (!hasVectors) {
        GTEST_SKIP() << "Test vectors not available - run TypeScript generator first";
    }
    
    std::string mnemonic = vectors["mnemonic"].get<std::string>();
    
    // Create member from mnemonic in C++
    auto member = Member::fromMnemonic(
        mnemonic,
        MemberType::User,
        "TestUser",
        "test@example.com"
    );
    
    // Derive voting keys in C++
    member.deriveVotingKeys(3072, 256);
    
    // Get TypeScript-derived keys from test vectors
    auto tsPublicKey = vectors["votingPublicKey"];
    auto tsN = hex_to_bytes(tsPublicKey["n"].get<std::string>());
    auto tsG = hex_to_bytes(tsPublicKey["g"].get<std::string>());
    
    auto tsPrivateKey = vectors["votingPrivateKey"];
    auto tsLambda = hex_to_bytes(tsPrivateKey["lambda"].get<std::string>());
    auto tsMu = hex_to_bytes(tsPrivateKey["mu"].get<std::string>());
    
    // Get C++-derived keys
    auto cppPub = member.votingPublicKey();
    auto cppPriv = member.votingPrivateKey();
    
    ASSERT_TRUE(cppPub != nullptr) << "C++ voting public key not derived";
    ASSERT_TRUE(cppPriv != nullptr) << "C++ voting private key not derived";
    
    // CRITICAL: Verify keys are IDENTICAL
    EXPECT_EQ(cppPub->n(), tsN) << "Public key modulus N does not match!";
    EXPECT_EQ(cppPub->g(), tsG) << "Public key generator G does not match!";
    
    // Verify we can encrypt/decrypt with both key sets
    auto tsPublicKeyObj = std::make_shared<PaillierPublicKey>(tsN, tsG);
    auto tsPrivateKeyObj = std::make_shared<PaillierPrivateKey>(tsLambda, tsMu, tsPublicKeyObj);
    
    // Test encryption with C++ keys, decryption with TS keys
    std::vector<uint8_t> testData = {0x42};
    auto cppEncrypted = cppPub->encrypt(testData);
    auto tsDecrypted = tsPrivateKeyObj->decrypt(cppEncrypted);
    EXPECT_EQ(tsDecrypted, testData) << "TS cannot decrypt C++ encrypted data!";
    
    // Test encryption with TS keys, decryption with C++ keys
    auto tsEncrypted = tsPublicKeyObj->encrypt(testData);
    auto cppDecrypted = cppPriv->decrypt(tsEncrypted);
    EXPECT_EQ(cppDecrypted, testData) << "C++ cannot decrypt TS encrypted data!";
}

TEST_F(MnemonicVotingKeyCrossPlatformTest, VotesAreInteroperable) {
    if (!hasVectors) {
        GTEST_SKIP() << "Test vectors not available";
    }
    
    std::string mnemonic = vectors["mnemonic"].get<std::string>();
    auto member = Member::fromMnemonic(mnemonic, MemberType::User, "TestUser", "test@example.com");
    member.deriveVotingKeys(3072, 256);
    
    // Load TS-encrypted votes from test vectors
    if (vectors.contains("encryptedVotes")) {
        for (const auto& voteData : vectors["encryptedVotes"]) {
            auto ciphertext = hex_to_bytes(voteData["ciphertext"].get<std::string>());
            int expectedValue = voteData["plaintext"].get<int>();
            
            // C++ should be able to decrypt TS-encrypted votes
            auto decrypted = member.votingPrivateKey()->decrypt(ciphertext);
            EXPECT_EQ(decrypted.back(), expectedValue) 
                << "C++ cannot decrypt TS vote correctly!";
        }
    }
}

TEST_F(MnemonicVotingKeyCrossPlatformTest, HomomorphicOperationsMatch) {
    if (!hasVectors) {
        GTEST_SKIP() << "Test vectors not available";
    }
    
    std::string mnemonic = vectors["mnemonic"].get<std::string>();
    auto member = Member::fromMnemonic(mnemonic, MemberType::User, "TestUser", "test@example.com");
    member.deriveVotingKeys(3072, 256);
    
    // Encrypt votes in C++
    std::vector<std::vector<uint8_t>> votes;
    votes.push_back(member.votingPublicKey()->encrypt({0x01}));
    votes.push_back(member.votingPublicKey()->encrypt({0x01}));
    votes.push_back(member.votingPublicKey()->encrypt({0x01}));
    
    // Add homomorphically
    auto sum = member.votingPublicKey()->addition(votes);
    auto result = member.votingPrivateKey()->decrypt(sum);
    
    EXPECT_EQ(result.back(), 3) << "Homomorphic addition failed!";
}

/**
 * Generate test vectors for TypeScript to verify
 * This test creates a JSON file that TypeScript can use to verify C++ derivation
 */
TEST_F(MnemonicVotingKeyCrossPlatformTest, GenerateCppTestVectors) {
    std::string testMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
    
    auto member = Member::fromMnemonic(testMnemonic, MemberType::User, "TestUser", "test@example.com");
    
    // Debug output
    auto privKey = member.privateKey();
    auto pubKey = member.publicKey();
    std::cout << "\nDEBUG - C++ ECDH Keys:\n  Private: ";
    for (auto b : privKey) printf("%02x", b);
    std::cout << "\n  Public:  ";
    for (auto b : pubKey) printf("%02x", b);
    std::cout << "\n\n";
    
    member.deriveVotingKeys(3072, 256);
    
    json output;
    output["mnemonic"] = testMnemonic;
    output["source"] = "cpp";
    
    if (member.hasVotingKeys()) {
        auto pub = member.votingPublicKey();
        auto priv = member.votingPrivateKey();
        
        output["votingPublicKey"]["n"] = bytes_to_hex(pub->n());
        output["votingPublicKey"]["g"] = bytes_to_hex(pub->g());
        
        json votes = json::array();
        for (int i = 0; i < 5; i++) {
            std::vector<uint8_t> plaintext = {static_cast<uint8_t>(i)};
            auto ciphertext = pub->encrypt(plaintext);
            
            json vote;
            vote["plaintext"] = i;
            vote["ciphertext"] = bytes_to_hex(ciphertext);
            votes.push_back(vote);
        }
        output["encryptedVotes"] = votes;
        
        std::ofstream outFile("test_vectors_cpp_voting.json");
        if (outFile.is_open()) {
            outFile << output.dump(2);
            std::cout << "Generated C++ test vectors in test_vectors_cpp_voting.json" << std::endl;
        }
    }
}
